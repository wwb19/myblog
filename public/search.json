[{"title":"【分享】限额控制的Redis实践","url":"/2018/07/22/share-redis-summary20180722/","content":"\n# 大纲\n* [需求](#overview)\n* [思考与方案](#useage)\n* [实现与困难](#stage)\n* [效果与总结](#summary)\n\n# 一、需求\n<a id=\"overview\"></a>\n* 需求比较简单，主要是实现多个维度的客户限额控制需求。每个限额的控制有多个的维度进行分别累计控制，还包括了单笔、日累计和月累计的方式。\n* 需要支持多个不同接入系统，而且需要考虑未来的业务扩展性。\n* 能够具有较强的实时性、响应性，而且能够稳定可持续运行。\n\n# 二、思考与方案\n<a id=\"useage\"></a>\n由于考虑这次项目是在支付系统中使用，常用场景是日常的高访问的支付场景以及一些秒杀、双十一等促销场景，而且涉及具有较大规模的基础用户量。自然而然，就想到了使用内存数据库进行处理。\n\n## 缓存or数据库\n内存数据库，顾名思义就是把数据放在内存中，直接把内存当作数据库使用。缓存，是内存数据库的应用场景之一，将进程使用的数据存在内存，达到共享、快速访问、减少数据交互的作用。但缓存毕竟不是数据库，缓存是可重新加载可丢失，而数据库却必须支持持久化、高可用、一致性的。\n在项目初期，我们基本考虑把数据存放在内存中。但随着项目的推进，压力测试、验证等各方面的工作开展，我们发现直接使用内存作为数据库在不可丢失数据的场景下，是无法满足要求的。至少，为了保持整个内存数据库的高可用、持久化，也许我们需要更多其他的工作来达到。\n因此，我们最终定型存储结构是Redis当作数据缓存以达到高并发的读写要求，DB2作为持久化数据库，最终数据需同步到DB2为准，也跟市场主流的用法类似。\n\n## 选用Redis\n缓存方案：Redis、ehcache、kafka等很多不同的方案。考虑行里已有Redis的实施经验，而且Redis提供的数据类型更为丰富，最重要是Redis支持持久化和成熟的高可用方案，初步定型为Redis。\n\n# 三、实现与困难\n<a id=\"stage\"></a>\n万事起头难，从无到有的确需要经过很多不同的实践和验证。从开始以为Redis只是普通的get/set操作，常用的k-v结构存储之外，其实对于一个成熟可用的方案考虑的还不止这些。\n\n## 数据存储\n* 数据规模\n\n存量客户数约5000千万左右。我们通过表格看看在这个基数下的不同额度的数据量。\n\n|  额度A  |  额度Ｂ  |  额度C  |\n| --- | --- | --- |\n|  基数x2  |  基数x42  |  基数x110 |\n|  1亿  |  十多亿  |  几百亿  |\n\n* 数据结构\n\n在如何规模的数量下，对于数据库都需要采取各种方案来进行提高性能和访问速度，还有节省空间。更何况是存储量级只有硬盘十分之一不到的内存呢。 \n在项目初期，确定以Redis为数据存储，DB2为数据存储的方案，与大多的方案不太一样。大多的方案是Redis的数据结构与数据库的表结构一致，根据不同的key来定义或划分数据。\n\n数据库：\n\n```\nLimitRecord1(\nuserid,recordval1,...\n)\nLimitRecord2(\nuserid,condition2,recordva2,...\n)\n```\n方案一：\n\n```\nRedis：\nLimitRecord1:userid{\n    recordval1:value,\n    ...\n}\nLimitRecord2:userid:condition2{\n    recordval2:value,\n    ...\n}\n\n```\n方案二：\n\n```\nRedis:\nuserid:{\n    LimitRecord1:recordval1\n    LimitRecord2.condition2:recordval1\n}\n```\n\n至于那种方式更好，见仁见智，在此我们提供不同思路给大家思考。\n对于缓存方案，多读少写第一种方案更合适。以Redis作为存储方案二相对更加节省内存使用，更适合k-v的存储数据结构。\n\n## Redis字段优化\n \n 在日常中，缓存往往只是少量数据，如配置项、热点数据等，而本项目中，Redis承载的数据规模日常热点在几千万键的级别中，因此每一个小的字符串优化，效果都很明显也很重要。\n优化前：\n\n```\nlimitkey.userid.cardtype等组合\n```\n优化后：\n\n```\nl.u.c 等组合\n甚至有些改为1.2.3纯数字代替\n```\n的确我们同事说的，这可读性降低很多，不过面对寸金尺土的内存空间，这优化还是很必要。\n\n另外，在Redis内存不同的数据结构对于内存的使用大小也是天差地别。\n\n|  存储结构  |  数据量（万）  |  数据格式  |内存大小|rdb文件大小|\n| --- | --- | --- |---|---|\n|  hash  |  15000  |  ziplist |10.77G|1.6G\n|  hash  |  15000  |  hashtable  |20.62G|6.9G\n\n当然我们也做了很多其他不同的字段优化和测试，在此边幅有限不一一详述。\n\n## 事务处理与lua脚本\n由于涉及多个限额的累计或回退、多个限额值（日累计、月累计）的一致性要求，数据库可提供事务机制实现，在Redis中，又是如何实现的。\nRedis提供了基础的事务功能，不过涉及到锁的机制，因此对于开发要求比较高。另一方面，Redis本身每次操作都是原子性的，所以也可通过lua脚本实现。我们本次项目采取的是后者。\n\nlua脚本并不复杂，但是lua脚本类似数据库的存储过程，一旦执行，若存在死循环或者大数据量操作，对于Redis来说是致命的。因此不建议常用，也不建议滥用，我们组员很多时间都觉得，lua可以做，就可以避免多次访问Redis，减少开销。不过遇到此类场景，并没有一致性要求的，建议使用hmset、hmget等批操作，或者pipeline等方式进行访问，避免使用lua此类脚本，减少风险和排查难度。\n\n## Redis与数据库同步\n在文章开头，提到一点很重要，也是项目必须面对的，就是Redis究竟是作为数据库还是缓存，这对于数据落地、高可用等设计都会涉及。\n目前定位是Redis缓存、DB作为数据落地，因此如何把Redis中的数据同步到数据库也是我们纠结很久的困难点。\n\n### 同步机制\n在Redis本身是支持类似队列或订阅机制，意味着我们可以考虑使用这两个方式触发数据同步。\n但由于Redis的队列机制是不完整的，不完整指的是Redis并不是提供一个类似MQ、rabbitMQ等专门的队列机制，因此不建议Redis的队列服务与本身Redis的存储服务一同使用，有可能会导致队列堵塞而导致存储服务无法使用。\n因此，项目使用了公司平台本身的队列服务，Redis仍然作为缓冲服务，避免由于高并发量和突发大数据量而导致系统不可用。\n\n### 数据结构映射\n如何把Redis的存储数据与数据库表结构对应，也是我们面对的问题之一。因此大多的方式是，Redis当缓存或临时的热点数据，允许在一段周期后进行丢弃，也就是说可不用回写数据库，但本项目中的数据，最长的时间是月，这个是无法丢弃的。并且如何对于这么大的数据量在Redis中进行清理，也是一个难题。\n\n\n### 解决方案\n另一方面，本项目采取的数据结构与数据库表结构也不一致，无法直接从Redis的数据中回写数据库。\n我们的处理方式就是不进行同步，Redis和数据库单独管理。每次通讯请求，通过开关判断，开关用于判断使用Redis或者DB。当默认使用Redis时，程序将请求同步发送至Redis限额控制服务，当Redis处理结果成功后，将请求异步发送至平台队列中，DB限额控制服务将从队列获取信息进行处理。\n\n\n　![](http://oxigzlivh.bkt.clouddn.com/2018-07-22-15322700497055.jpg)\n\n\n# 四、效果与总结\n<a id=\"summary\"></a>\n目前项目仍在开发中准备投产，效果如何仍需结合生产的运行情况，我们再进一步总结和归纳经验。本项目在Redis中的前期做了不少的实践，不过更多没落到实处，主要集中在性能和用法上的实践。但在项目开展时会遇到不少的难题需要解决，特别结合复杂的业务场景下，无法使用关系型数据库进行数据关联查询，无法使用事务机制控制提交回滚，更无法使用索引主键等控制约束，都是我们缺乏思考的地方。\n下一步我们需要完善的是运维和监控，在追求速度的开发节奏和生产性能的当下，如何能够让快速的系统健康稳定运行，相对应的故障发现和自动化运维机制是必不可少的。期待下一次的分享。\n\n","tags":["项目"],"categories":["分享"]},{"title":"【培训】公司Redis分享会","url":"/2018/06/22/work-redisMeeting/","content":"\n# 大纲\n* [Redis介绍](#overview)\n* [Redis使用](#useage)\n* [Redis场景](#stage)\n* [Redis实践](#practice)\n\n# 一、Redis介绍\n<a id=\"overview\"></a>\n## 概述\nRemote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。\n\nRedis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n\n它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\n## 特性\n* Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n\n* Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n\n* Redis支持数据的备份，即master-slave模式的数据备份。\n\n## 数据结构\n### Redis支持五种数据类型：\n```\n//type的占5种类型：\n/* Object types */\n#define OBJ_STRING 0    //字符串对象\n#define OBJ_LIST 1      //列表对象\n#define OBJ_SET 2       //集合对象\n#define OBJ_ZSET 3      //有序集合对象\n#define OBJ_HASH 4      //哈希对象\n```\n\n### Redis底层的十种基础数据结构（3.2）\n```\n// encoding 的10种类型\n#define OBJ_ENCODING_RAW 0          //原始表示方式，字符串对象是简单动态字符串\n#define OBJ_ENCODING_INT 1          //long类型的整数\n#define OBJ_ENCODING_HT 2           //字典\n#define OBJ_ENCODING_ZIPMAP 3       //不在使用\n#define OBJ_ENCODING_LINKEDLIST 4   //双端链表,不在使用\n#define OBJ_ENCODING_ZIPLIST 5      //压缩列表\n#define OBJ_ENCODING_INTSET 6       //整数集合\n#define OBJ_ENCODING_SKIPLIST 7     //跳跃表和字典\n#define OBJ_ENCODING_EMBSTR 8       //embstr编码的简单动态字符串\n#define OBJ_ENCODING_QUICKLIST 9    //由压缩列表组成的双向列表-->快速列表\n```\n\n### 相互关系\n|  数据类型  |             基础数据结构 |\n|----------|-------------------------|\n|String    |INT,EMBSTR,RAW           |\n|LIST      |ZIPLIST,QUICKLIST        |\n|HASH      |ZIPLIST,HT(HASHTABLE)    |\n|SET       |INTSET,HT                |\n|ZSET      |ZIPLIST,SKIPLIST         |\n\n## 优势\n* 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n\n* 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n\n* 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n\n* 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n# 二、Redis使用\n<a id=\"useage\"></a>\n## 安装方式\n请参考另一篇文章{% post_link course-redisInstall [Redis 3.2 详细安装步骤说明]%}\n## 常用命令\n[常用命令介绍](https://www.cnblogs.com/kevinws/p/6281395.html)\n## 持久化介绍\nRedis 分别提供了 RDB 和 AOF 两种持久化机制： \n\n* RDB \n将数据库的快照（snapshot）以二进制的方式保存到磁盘中。\n* AOF \n则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。\n\n## 高可用\n### 主从同步\n\n### 哨兵模式\nSentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。\n参考部署架构图\n\n* 正常状态下：（A-主，B、C为从）\n![](http://oxigzlivh.bkt.clouddn.com/2018-06-23-15297206515518.jpg)\n\n* Master掉线后：\n![](http://oxigzlivh.bkt.clouddn.com/2018-06-23-15297206846504.jpg)\n\n* 选举升级Slave为Master：\n![](http://oxigzlivh.bkt.clouddn.com/2018-06-23-15297207006886.jpg)\n\n* 恢复正常后：\n![](http://oxigzlivh.bkt.clouddn.com/2018-06-23-15297207149684.jpg)\n\n\n# 三、Redis场景\n<a id=\"stage\"></a>\n## 表数据缓存\n使用方式：直接把表数据加载至Redis中，数据类型为Hash，常用的数据库缓存的用法之一。\n\n* 一般用法：\n\n```\n如：\n **表名：**TableName\n **字段：**A,B,C,D\n 转换为Redis的存为：(结构为hash)\n **Key：**T_TableName_唯一索引\n **Field：**\n {a:val1,b:val2,c:val3,d:val4}\n```\n \n* 说明：\n此类一般保持少量并且常用的字段加载到内存中进行缓存使用，因此需要保证Field的数据量条数不多并且val字段长度不大，尽量使用Ziplist以便节省内存空间。\n## NoSQL数据库\n使用方式：直接以Redis作为数据库存储，可以同表数据缓存方式进行存放，或重新定义所需的数据结构。\n\n* 一般用法：\n\n```\n如：对象User\n\nKey为：User:uid\nField：对应属性字段\n或\nKey为：User\nField:uid.属性字段\n```\n\n* 说明：\n需要进行数据量的评估和考虑数据结构对于内存的使用。\n因为在Redis中，若所有数据均以Key-Vale的方式存放，每个key除了自身数据外，还需保留RedisObeject本身的数据空间，因此占用较大，可考虑转为Hash-Field的方式进行数据存放。\n但Hash使用两种数据结构，一个是ZipList一个是HashTable，若使用HashTable方式存放，则内存空间无法节省，因此需结合具体情况定义不同的数据结构使用方式。\n\n## 消息队列（生产者消费模式）\nRedis不仅可作为缓存服务器，还可用作消息队列。它的列表类型天生支持用作消息队列。\nRedis提供了两种方式来作消息队列。 \n一个是使用生产者消费模式，另一个就是发布订阅者模式。 \n前者会让一个或者多个客户端监听消息队列，一旦消息到达，消费者马上消费，谁先抢到算谁的，如果队列里没有消息，则消费者继续监听。 \n后者也是一个或多个客户端订阅消息频道，只要发布者发布消息，所有订阅者都能收到消息，订阅者都是平等的。\n如下图所示：\n\n![](http://oxigzlivh.bkt.clouddn.com/2018-06-23-15297224494777.jpg)\n\n由于Redis的列表是使用双向链表实现的，保存了头尾节点，所以在列表头尾两边插取元素都是非常快的。所以可以直接使用Redis的List实现消息队列，只需简单的两个指令lpush和rpop或者rpush和lpop。\n\n## 流水号判重\nRedis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。\nRedis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n我们可以使用Set进行**流水号判重操作**\n\n```\n如：\nKey:serno_YYYYMMDD\nSet:[serno1,serno2 ... sernoN]\n\nCommand：\nSADD serno_YYYYMMDD sernoX \n加入Set中，若已存在则返回0，若加入成功则返回1\n```\n\n# 四、Redis实践\n<a id=\"practice\"></a>\n## 支付系统-额度服务\n请参考另一篇文章{% post_link practice-redis-s00 [【实践】记Redis使用实践 ]%}\n## Redis数据迁移\n方案进行中，后续分享。\n\n \n\n","tags":["会议"],"categories":["培训"]},{"title":"【教程】Redis 3.2 详细安装步骤说明","url":"/2018/06/18/course-redisInstall/","content":"\n\n# Note\n>本文用于Redis的部署安装\n>配置文件内容需根据实际情况进行设置\n>本文为Sentinel哨兵模式的集群搭建，若需Cluster集群模式，可查看Redis安装部署内容，集群安装不适合。\n\n# 一、部署说明\n\n## 集群信息\n\n* 集群：1主2从\n\n* master：主服务器\n\n* slave：从服务器\n\n同步时间间隔：1s。每秒中，slave从master进行数据同步操作。\n\n## 硬件配置要求\n\n|配置项|内容|\n| --- | --- | \n| CPU | 4c\\*2.4g | \n| 内存 | 32g |\n| 磁盘 | 1000G |\n| 系统版本 | Redhat 7.3 |\n| Redis版本 | 3.2.11 |\n\n* 哨兵集群：Redis-Sentiel\n\n相互服务发现机制，通过选举确定master是否可用。\n\n选举配置：2。意味着3台中只要有两台无法与master通讯时，进行切换master操作。\n\n* 读写分离\n\nMaster作为写服务器，Salve作为读服务器。通过数据同步，保证主从数据一致。\n\n# 二、安装部署\n\n## 1、redis安装部署步骤\n\n### Master节点安装\n\n#### 1、安装系统依赖包\n```\nyum install --downloadonly --downloaddir=/tmp/download\n```\n\n```\nyum -y install gcc automake autoconf libtool make telnet ruby-devel ruby-irb ruby-libs ruby-rdoc ruby rubygems-devel rubygems\n```\n#### 2、安装ruby包\n```\nyum -y install centos-release-scl-rh centos-release-scl\n\nsed -i -e s/\\]$/\\]\\npriority=10/g /etc/yum.repos.d/CentOS-SCLo-scl.repo\n\nsed -i -e s/\\]$/\\]\\npriority=10/g /etc/yum.repos.d/CentOS-SCLo-scl-rh.repo\n\nsed -i -e s/enabled=1/enabled=0/g /etc/yum.repos.d/CentOS-SCLo-scl.repo\n\nsed -i -e s/enabled=1/enabled=0/g /etc/yum.repos.d/CentOS-SCLo-scl-rh.repo\n\nyum --enablerepo=centos-sclo-rh -y install rh-ruby22\n\nscl enable rh-ruby22 bash\n\nruby –v\n```\n\n#### 3、安装reids ruby控制包\n\n```\ngem install redis\n```\n\n#### 4、安装redis\n```\ncd  /tmp\n\nyum install -y wget\n\nwget http://download.redis.io/releases/redis-3.2.11.tar.gz\n\ntar -zxf redis-3.2.11.tar.gz\n\ncd redis-3.2.11\n\nmake\n\ncd src &amp;&amp; make install PREFIX=/usr/local/redis\n\ncd ..\n\nmkdir /usr/local/redis/etc\n\nmkdir /usr/local/redis/db\n\ncp redis.conf /usr/local/redis/etc/\n\ncp ./src/redis-trib.rb /usr/local/redis/bin/\n```\n#### 5、修改配置文件\n```\nvi /usr/local/redis/etc/redis.conf\n\n#bind 127.0.0.1 #这里注释掉，否则会导致其它节点无法与本节点通信\n\nprotected-mode yes\n\ndaemonize yes #用守护模式启动\n\npidfile /var/run/redis\\_6379.pid #不同机器PID文件不一样，我们用7001-7006 #可以用同一个，但是为了统一还是建议改成不同的\n\nlogfile /var/log/redis.log\n\ndir /usr/local/redis/db/\n\nmasterauth password\n\nrequirepass password\n\nappendonly yes #开启AOF模式\n```\n\n### Slave节点安装\n\n#### 同上1-4\n\n#### 修改配置文件\n```\nvi /usr/local/redis/etc/redis.conf\n\n#bind 127.0.0.1 #这里注释掉，否则会导致其它节点无法与本节点通信\n\nprotected-mode yes\n\ndaemonize yes #用守护模式启动\n\nport 6379 #修改为port 6380\n\n#增加 slaveof 192.168.81.129 6380\n\nslaveof 172.20.10.12 6379\n\npidfile /var/run/redis\\_6380.pid #不同机器PID文件不一样， #可以用同一个，但是为了统一还是建议改成不同的\n\nlogfile /var/log/redis.log\n\ndir /usr/local/redis/db/\n\nmasterauth password\n\nrequirepass password\n\nappendonly yes #开启AOF模式\n```\n增加requirepass password，这是设置redis客户端或者远程机器连接redis服务器需要的密码，这里同样设为redis（6381的密码也设为redis）\n\n### Sential哨兵安装\n\n#### 安装哨兵\n\n哨兵与redis在同一服务器下，无需安装，redis自带。\n\n若与redis不在统一服务器下，可参考上redis安装1-4步骤。\n\n#### 修改配置（每个哨兵配置，除监听端口外，其他保持一致）\n```\ncd /tmp/redis-3.2.11\n```\n复制配置到 etc目录\n\n```\ncp sentinel.conf /usr/local/redis/etc/sentinel.conf\n\nvi /usr/local/redis/etc/sentinel.conf\n\n增加\n\nbind 0.0.0.0\n\n端口是 26379\n\n增加：\n\ndaemonize yes\n\nlogfile /var/log/sentinel.log\n\n搜索 sentinel monitor  下面增加\n\nsentinel monitor mymaster 172.20.10.12 6379 2\n\n对sentinel monitor mymaster 192.168.81.129 6379 2\n```\n\n解释：\nmymaster ：为主服务器起的名字；\n\n192.168.81.129 6379：主服务器的ip和端口号\n\n2：代表有2个哨兵认为主服务器主观下线时，则认为主服务器是客观下线了，可以执行主从切换，并进行故障转移操作\n\n```\n搜索 auth-pass  下面增加ps\nsentinel auth-pass mymaster password\n```\n\n## 2、集群启动\n\n### 启动redis集群：\n\n#### 服务器A：\n\nredis – 6379\n\n哨兵-26379\n\n/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf\n\n#### 服务器B：\n\nredis – 6380\n\n哨兵-26380\n\n/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf\n\n#### 服务器C：\n\nredis – 6381\n\n哨兵-26381\n\n/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf\n\n### 启动哨兵集群：\n\n#### 服务器A：\n\n/usr/local/redis/bin/redis-sentinel /usr/local/redis/etc/sentinel.conf\n\n#### 服务器B：\n\n/usr/local/redis/bin/redis-sentinel /usr/local/redis/etc/sentinel.conf\n\n#### 服务器C：\n\n/usr/local/redis/bin/redis-sentinel /usr/local/redis/etc/sentinel.conf\n\n\n\n## 3、安装验证\n\n### 集群部署验证\n```\n/usr/local/redis/bin/redis-cli\n\n  127.0.0.1:6379 auth password\n\n  OK\n\n  127.0.0.1:6379 info replication\n\n# Replication\n\nrole:master\n\nconnected\\_slaves:2\n\nslave0:ip=172.17.0.1,port=6380,state=online,offset=407,lag=1\n\nslave1:ip=172.17.0.1,port=6381,state=online,offset=407,lag=1\n\nmaster\\_repl\\_offset:407\n\nrepl\\_backlog\\_active:1\n\nrepl\\_backlog\\_size:1048576\n\nrepl\\_backlog\\_first\\_byte\\_offset:2\n\nrepl\\_backlog\\_histlen:406\n```\n\n#### 查询验证\n\n```\n/usr/local/redis/bin/redis-cli -h 172.20.10.12 -p 6380\n\n  127.0.0.1:6380 auth password\n\n  OK\n\n  127.0.0.1:6380 keys \\*\n\n  (empty list or set)\n```\n  \n#### 新增验证\n\n无\n\n","tags":["生产"],"categories":["教程"]},{"title":"【项目】记Redis使用实践-介绍","url":"/2018/06/18/project-redis-s00/","content":"# 大纲\n* 一、项目背景\n* 二、数据结构\n* 三、Redis使用\n* 四、Redis数据同步\n* 五、特别场景说明\n* 六、总结优化\n\n# 感受\n  从今年的3月底，接收到一个蛮有挑战的任务，就是用redis解决目前项目的一个额度服务需求。\n  领导很简单地说了几句，用Redis就可以解决，当然我也觉得就一个内存的k-v数据库，应该也还好，就接收了这个任务。\n  接触发现，Redis涉及的面不少，不单单数据结构，还有深入需求后发现，其实数据结构也是一个很大的挑战，因为单单同步表数据，量有点大。走序列化，跟已有的技术平台不太兼容，最后只能选择重新设计数据结构，进行映射。\n  最后，经过几个月的学习研究。从一个没有接触过Redis的小白，总算折腾出了一个以Redis作为缓存的额度服务系统。希望能够分享出来。\n\n","tags":["教程"],"categories":["实践"]},{"title":"【实践】记Redis使用实践一：项目背景","url":"/2018/06/18/project-redis-s01/","content":"\n# 背景 \n作为程序员一个，多年来的工作习惯，啥都是要讲需求背景，所以直接来干货。\n这次我们涉及的是支付系统中的一个功能服务，在一家大行中提供全行的交易限额控制服务。\n其中这个额度不单单只是一维的限制，还需要根据不同的场景和对接系统，提供多个不同纬度的额度限制。\n简单概括。但是实践起来又是另一回事。\n\n# 过程\n## 划重点\n当收到需求，常习惯看一遍划重点。\n* 数据量\n* 并发量\n* 复杂度\n* 一致性\n* 多维度\n\n## 分析\n### 数据量\n存量客户数约5000千万左右。我们通过表格看看在这个基数下的不同额度的数据量。\n\n|  额度A  |  额度Ｂ  |  额度C  |\n| --- | --- | --- |\n|  基数x2  |  基数x42x6  |  基数x110 |\n|  1亿  |  一百多亿  |  几百亿  |\n当然，基本不太可能全部量都同时存在，不过基于进行评估需要，仍然以此作为评估的基数。\n\n### 并发量\n由于属于支付系统，要求的TPS是2000左右。在双11或者秒杀活动中，这个TPS可能还会进一步提升。 因此初步设计需要约5000TPS左右\n\n### 复杂度\n对于系统的需求其实比较简单，比起那些复杂的支付逻辑来说，这个还是比较简单。但是由于考虑的是系统的通用性和扩展性，这个就没法根据需求来硬编码了。\n\n### 一致性\n其实这个在数据库来说，意思就是事务一致性。因为需要对于多个额度同时进行控制，所以如何保证多个额度能一起累计或一起撤回，是考虑的重要规则之一。\n\n### 多维度\n也是基于需求背景，结合复杂度和一致性考虑，如何处理不同纬度的额度限制，并且能够具有一定的扩展性。\n\n## 设计\n有了上面的需求硬指标，我们就开始着手设计。\n主要考虑的重点就是性能和数据量\n如何在大的用户基数下也能兼顾高并发的访问性能，相信很多人都会有这个疑问。现在介绍一下我们的思路。\n### 性能\n内存存储，考虑到这么高的并发访问，而且存在高读写的要求，基于这个我们决定使用Redis作为我们数据的存储。\n\n### 数据量\n既然选择了Redis，那就从Redis开始着手进行分析解决。\n内存能不能存放这么大的数据量呢？答案是可以。不过合不合理，适不适合，又是另一件事了。\n在Redis的设计中，有几个通用的规范，来减少内存的开销。\n* 避免大key\n* 避免key和val过长\n* 尽量使用ziplist数据结构\n\n# 总结\n基本介绍了项目的背景和设计所需考虑的一些关键点，下一章节将详细说明一下数据结构。\n\n","tags":["教程"],"categories":["实践"]},{"title":"【记Redis使用实践】分享","url":"/2018/06/18/redis-s00/","content":"# 大纲\n* 一、项目背景\n* 二、数据结构\n* 三、Redis使用\n* 四、Redis数据同步\n* 五、特别场景说明\n* 六、总结优化\n\n# 感受\n  从今年的3月底，接收到一个蛮有挑战的任务，就是用redis解决目前项目的一个额度服务需求。\n  领导很简单地说了几句，用Redis就可以解决，当然我也觉得就一个内存的k-v数据库，应该也还好，就接收了这个任务。\n  接触发现，Redis涉及的面不少，不单单数据结构，还有深入需求后发现，其实数据结构也是一个很大的挑战，因为单单同步表数据，量有点大。走序列化，跟已有的技术平台不太兼容，最后只能选择重新设计数据结构，进行映射。\n  最后，经过几个月的学习研究。从一个没有接触过Redis的小白，总算折腾出了一个以Redis作为缓存的额度服务系统。希望能够分享出来。","tags":["教程"]},{"title":"【记Redis使用实践一】项目背景","url":"/2018/06/18/redis-s01/","content":"\n# 背景 \n作为程序员一个，多年来的工作习惯，啥都是要讲需求背景，所以直接来干货。\n这次我们涉及的是一个支付系统中的一个功能服务，在一家大行中提供全行的交易额度限制服务。\n其中额度不单单只是一维的限制，还需要根据不同的场景和对接系统，提供多个不同纬度的额度限制。\n简单概括。但是实践起来又是另一回事。\n\n# 过程\n## 划重点\n当收到需求，常习惯看一遍划重点。\n* 数据量\n* 并发量\n* 复杂度\n* 一致性\n* 多维度\n\n## 分析\n### 数据量\n存量客户数约5000千万左右。我们通过表格看看在这个基数下的不同额度的数据量。\n\n|  额度A  |  额度Ｂ  |  额度C  |\n| --- | --- | --- |\n|  2  |  42x6  |  6x18x110 |\n|  1亿  |  一百多亿  |  上千亿  |\n当然，基本不太可能全部量都同时存在，不过基于进行评估需要，仍然以此作为评估的基数。\n\n### 并发量\n由于属于支付系统，要求的TPS是2000左右。在双11或者秒杀活动中，这个TPS可能还会进一步提升。 因此初步设计需要约5000TPS左右\n\n### 复杂度\n对于系统的需求其实比较简单，比起那些复杂的支付逻辑来说，这个还是比较简单。但是由于考虑的是系统的通用性和扩展性，这个就没法根据需求来硬编码了。\n\n### 一致性\n其实这个在数据库来说，意思就是事务一致性。因为需要对于多个额度同时进行控制，所以如何保证多个额度能一起累计或一起撤回，是考虑的重要规则之一。\n\n### 多维度\n也是基于需求背景，结合复杂度和一致性考虑，如何处理不同纬度的额度限制，并且能够具有一定的扩展性。\n\n## 设计\n有了上面的需求硬指标，我们就开始着手设计。\n主要考虑的重点就是性能和数据量\n如何在大的用户基数下也能兼顾高并发的访问性能，相信很多人都会有这个疑问。现在介绍一下我们的思路。\n### 性能\n内存存储，考虑到这么高的并发访问，而且存在高读写的要求，基于这个我们决定使用Redis作为我们数据的存储。\n\n### 数据量\n既然选择了Redis，那就从Redis开始着手进行分析解决。\n内存能不能存放这么大的数据量呢？答案是可以。不过合不合理，适不适合，又是另一件事了。\n在Redis的设计中，有几个通用的规范，来减少内存的开销。\n* 避免大key\n* 避免key和val过长\n* 尽量使用ziplist数据结构\n\n# 总结\n基本介绍了项目的背景和设计所需考虑的一些关键点，下一章节将详细说明一下数据结构。","tags":["教程"]},{"title":"我的第一个父亲节","url":"/2018/06/17/2018-06-18-blog/","content":"\n# 新生命的到来\n作为一个新进奶爸，第一个父亲对于我来说，就多了一个身份，即是孩子，也是父亲。\n![](http://oxigzlivh.bkt.clouddn.com/15292965985482.jpg)\n\n## 变化\n### 衣\n现在衣服，总量也许已经比我多得多咯。啊哈哈，有专门的一个大衣柜，还有床底的位置都已经放满了衣服。而且只是一岁左右的衣服，他奶奶每次逛街都会买。还有大哥哥姐姐给，哈哈哈。都可以开店咯。\n### 食\n食的方面还好，就是由于老婆只能吃清淡的，需要喂母乳，所以一切 串串小龙虾啊，她都要远离，而且还是吃吃吃。\n### 住\n住的话，就是离不开睡觉呗，摇摇床，婴儿专用的床垫啊，还有BB床，一应俱全。至于睡那一张，就看他喜爱了。哈哈哈。他最爱睡就是我们的手臂。那叫一个酸啊。\n### 行\n出行对于新生儿来说，的确是一个大工程。BB车，爸爸袋，一大堆要准备的。初学奶爸，经常忘记带东西，特别是奶瓶。被吐槽好几回咯。还有热水、45度的常温水～～～好咯，小本本跟上。\n# 两个心脏的距离\n## 喜\n的确，多了一个孩子是一件喜事。各种话题聊天都是离不开孩子的事。欢喜的是，孩子最重要是健健康康，欢欢乐乐就满足了。\n## 怒\n这个是怒，哈，都不知道是 孩子的怒，还是作为父母的怒。的确很多时候很想发火，不过，心里总是压着压着。想起一句话，自己生的娃，怎么也得认了吧。哈哈哈。\n孩子，一个就是饿，一个就是困。哭得最厉害。解决这个问题啊，孩子一笑，好像一切的怒火都没了。好咯，也许这就是作为父母的最无可奈何的地方吧。\n## 哀\n何来哀，还不是孩子的健康成长。各种担心，各种害怕。一惊一咋。不过先好多了，熟悉了孩子的脾性，也知道很多时候是怎么一回事，不会像刚刚一样，措手不及啊。\n## 乐\n孩子带来家里的笑声更多了。\n孩子的笑声，还有逗着孩子玩的笑声，满屋子都是。\n\n\n","tags":["生活"]},{"title":"Welcome on WWB1984","url":"/1984/08/08/hello-world/","content":"\n# Welcome My World\n首先，欢迎大家到来。\n这是第一篇的文章，后续我会继续在这里分享。\n当你看到里面的每一段文字，也是我们不同平行线上的交集。是幸运、更是幸福。\n希望能够珍惜彼此短短的交集。\n谢谢。\n\n## 声明：\n1、不要当键盘侠，前提。本人玻璃心受不了。\n2、有错就认，欢迎提出。\n3、版权相关，请标明出处。\n","tags":["博客"]},{"title":"Welcome on WWB1984","url":"/1984/08/08/point-welcome/","content":"\n# Welcome My World\n首先，欢迎大家到来。\n这是第一篇的文章，后续我会继续在这里分享。\n当你看到里面的每一段文字，也是我们不同平行线上的交集。是幸运、更是幸福。\n希望能够珍惜彼此短短的交集。\n谢谢。\n\n## 声明：\n1、不要当键盘侠，前提。本人玻璃心受不了。\n2、有错就认，欢迎提出。\n3、版权相关，请标明出处。\n\n\n","tags":["生活"],"categories":["观点"]}]