---
title:  【分享】限额控制的Redis实践
date: 2018-07-22 23:03:03
tags: 
    - 技术 
    - redis 
    - 项目
    - 生产
categories:
    - 技术
    - 分享
copyright: true
---

# 大纲
* [需求](#overview)
* [思考与方案](#useage)
* [实现与困难](#stage)
* [效果与总结](#summary)

# 一、需求
<a id="overview"></a>
* 需求比较简单，主要是实现多个维度的客户限额控制需求。每个限额的控制有多个的维度进行分别累计控制，还包括了单笔、日累计和月累计的方式。
* 需要支持多个不同接入系统，而且需要考虑未来的业务扩展性。
* 能够具有较强的实时性、响应性，而且能够稳定可持续运行。
<!-- more --> 
# 二、思考与方案
<a id="useage"></a>
由于考虑这次项目是在支付系统中使用，常用场景是日常的高访问的支付场景以及一些秒杀、双十一等促销场景，而且涉及具有较大规模的基础用户量。自然而然，就想到了使用内存数据库进行处理。

## 缓存or数据库
内存数据库，顾名思义就是把数据放在内存中，直接把内存当作数据库使用。缓存，是内存数据库的应用场景之一，将进程使用的数据存在内存，达到共享、快速访问、减少数据交互的作用。但缓存毕竟不是数据库，缓存是可重新加载可丢失，而数据库却必须支持持久化、高可用、一致性的。
在项目初期，我们基本考虑把数据存放在内存中。但随着项目的推进，压力测试、验证等各方面的工作开展，我们发现直接使用内存作为数据库在不可丢失数据的场景下，是无法满足要求的。至少，为了保持整个内存数据库的高可用、持久化，也许我们需要更多其他的工作来达到。
因此，我们最终定型存储结构是Redis当作数据缓存以达到高并发的读写要求，DB2作为持久化数据库，最终数据需同步到DB2为准，也跟市场主流的用法类似。

## 选用Redis
缓存方案：Redis、ehcache、kafka等很多不同的方案。考虑行里已有Redis的实施经验，而且Redis提供的数据类型更为丰富，最重要是Redis支持持久化和成熟的高可用方案，初步定型为Redis。

# 三、实现与困难
<a id="stage"></a>
万事起头难，从无到有的确需要经过很多不同的实践和验证。从开始以为Redis只是普通的get/set操作，常用的k-v结构存储之外，其实对于一个成熟可用的方案考虑的还不止这些。

## 数据存储
* 数据规模

存量客户数约5000千万左右。我们通过表格看看在这个基数下的不同额度的数据量。

|  额度A  |  额度Ｂ  |  额度C  |
| --- | --- | --- |
|  基数x2  |  基数x42  |  基数x110 |
|  1亿  |  十多亿  |  几百亿  |

* 数据结构

在如何规模的数量下，对于数据库都需要采取各种方案来进行提高性能和访问速度，还有节省空间。更何况是存储量级只有硬盘十分之一不到的内存呢。 
在项目初期，确定以Redis为数据存储，DB2为数据存储的方案，与大多的方案不太一样。大多的方案是Redis的数据结构与数据库的表结构一致，根据不同的key来定义或划分数据。

数据库：

```
LimitRecord1(
userid,recordval1,...
)
LimitRecord2(
userid,condition2,recordva2,...
)
```
方案一：

```
Redis：
LimitRecord1:userid{
    recordval1:value,
    ...
}
LimitRecord2:userid:condition2{
    recordval2:value,
    ...
}

```
方案二：

```
Redis:
userid:{
    LimitRecord1:recordval1
    LimitRecord2.condition2:recordval1
}
```

至于那种方式更好，见仁见智，在此我们提供不同思路给大家思考。
对于缓存方案，多读少写第一种方案更合适。以Redis作为存储方案二相对更加节省内存使用，更适合k-v的存储数据结构。

## Redis字段优化
 
 在日常中，缓存往往只是少量数据，如配置项、热点数据等，而本项目中，Redis承载的数据规模日常热点在几千万键的级别中，因此每一个小的字符串优化，效果都很明显也很重要。
优化前：

```
limitkey.userid.cardtype等组合
```
优化后：

```
l.u.c 等组合
甚至有些改为1.2.3纯数字代替
```
的确我们同事说的，这可读性降低很多，不过面对寸金尺土的内存空间，这优化还是很必要。

另外，在Redis内存不同的数据结构对于内存的使用大小也是天差地别。

|  存储结构  |  数据量（万）  |  数据格式  |内存大小|rdb文件大小|
| --- | --- | --- |---|---|
|  hash  |  15000  |  ziplist |10.77G|1.6G
|  hash  |  15000  |  hashtable  |20.62G|6.9G

当然我们也做了很多其他不同的字段优化和测试，在此边幅有限不一一详述。

## 事务处理与lua脚本
由于涉及多个限额的累计或回退、多个限额值（日累计、月累计）的一致性要求，数据库可提供事务机制实现，在Redis中，又是如何实现的。
Redis提供了基础的事务功能，不过涉及到锁的机制，因此对于开发要求比较高。另一方面，Redis本身每次操作都是原子性的，所以也可通过lua脚本实现。我们本次项目采取的是后者。

lua脚本并不复杂，但是lua脚本类似数据库的存储过程，一旦执行，若存在死循环或者大数据量操作，对于Redis来说是致命的。因此不建议常用，也不建议滥用，我们组员很多时间都觉得，lua可以做，就可以避免多次访问Redis，减少开销。不过遇到此类场景，并没有一致性要求的，建议使用hmset、hmget等批操作，或者pipeline等方式进行访问，避免使用lua此类脚本，减少风险和排查难度。

## Redis与数据库同步
在文章开头，提到一点很重要，也是项目必须面对的，就是Redis究竟是作为数据库还是缓存，这对于数据落地、高可用等设计都会涉及。
目前定位是Redis缓存、DB作为数据落地，因此如何把Redis中的数据同步到数据库也是我们纠结很久的困难点。

### 同步机制
在Redis本身是支持类似队列或订阅机制，意味着我们可以考虑使用这两个方式触发数据同步。
但由于Redis的队列机制是不完整的，不完整指的是Redis并不是提供一个类似MQ、rabbitMQ等专门的队列机制，因此不建议Redis的队列服务与本身Redis的存储服务一同使用，有可能会导致队列堵塞而导致存储服务无法使用。
因此，项目使用了公司平台本身的队列服务，Redis仍然作为缓冲服务，避免由于高并发量和突发大数据量而导致系统不可用。

### 数据结构映射
如何把Redis的存储数据与数据库表结构对应，也是我们面对的问题之一。因此大多的方式是，Redis当缓存或临时的热点数据，允许在一段周期后进行丢弃，也就是说可不用回写数据库，但本项目中的数据，最长的时间是月，这个是无法丢弃的。并且如何对于这么大的数据量在Redis中进行清理，也是一个难题。


### 解决方案
另一方面，本项目采取的数据结构与数据库表结构也不一致，无法直接从Redis的数据中回写数据库。
我们的处理方式就是不进行同步，Redis和数据库单独管理。每次通讯请求，通过开关判断，开关用于判断使用Redis或者DB。当默认使用Redis时，程序将请求同步发送至Redis限额控制服务，当Redis处理结果成功后，将请求异步发送至平台队列中，DB限额控制服务将从队列获取信息进行处理。


　![](http://oxigzlivh.bkt.clouddn.com/2018-07-22-15322700497055.jpg)


# 四、效果与总结
<a id="summary"></a>
目前项目仍在开发中准备投产，效果如何仍需结合生产的运行情况，我们再进一步总结和归纳经验。本项目在Redis中的前期做了不少的实践，不过更多没落到实处，主要集中在性能和用法上的实践。但在项目开展时会遇到不少的难题需要解决，特别结合复杂的业务场景下，无法使用关系型数据库进行数据关联查询，无法使用事务机制控制提交回滚，更无法使用索引主键等控制约束，都是我们缺乏思考的地方。
下一步我们需要完善的是运维和监控，在追求速度的开发节奏和生产性能的当下，如何能够让快速的系统健康稳定运行，相对应的故障发现和自动化运维机制是必不可少的。期待下一次的分享。

